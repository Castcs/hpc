Cameron  Stiver - HPC Assignment 1
I messed with dgemm-blocked.c a bit. I tried to add the #pragma GCC optimize (“peel-loops”) line at the start but that didn’t seem to do anything, i assume i might have had to tweak some GCC settings or use a different module or something. Where I saw actual performance increases was adjusting the BLOCK_SIZE and unrolling the innermost loop in the do_block method. The BLOCK_SIZE seemed to make a pretty immediate impact, but it seemed to speed the process up going DOWN in block size. My understanding, which is probably wrong, is that the smaller block size helps keep things more local. I understand that unrolling the innermost loop of the method that actually does the math would help reduce some of the overhead of constantly iterating through a for loop and constantly checking the loop condition. I guess I could have tried unlooping more, but I wasn’t sure if it could continue to have as much of a gain, while it would get more and more complex for me and probably increase my odds of messing up. I’m at least glad I tried to unroll that innermost loop manually.

I tried a few things along the same lines as the peel-loops pragma statement, but they didn't seem to do much. I also messed with the CMakeLists.txt file and I figured I should see some huge performance increases, but I guess I may have done something wrong there? I thought changing the -march target architecture would do something, but I didn't see any performance change after doing so. Sometimes I really thought my build/make process was incorrect because I wouldn’t see changes after changing something I really thought would make a difference. I think I read through -march –help options and tried switching to one specific to this CPU's architecture, then I tried “native” which would apparently do something, but I didn’t see any performance increases. 

I see the benefit in the blocked approach over naive. Adjusting the block size seemed to have a dramatic difference in performance and I could see how matching that perfectly with the cache size of the processor could vastly improve performance. The blas system I don't really get to see what’s going on since it’s an outside library, but I think that just takes some of the principles I tried to apply to the blocked method to the furthest extent and optimizes specifically to the system architecture you use.
